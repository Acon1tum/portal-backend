generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Sex {
  MALE
  FEMALE
  OTHERS
}

enum Status {
  ACTIVE
  INACTIVE
}

enum VerificationStatus {
  VERIFIED
  UNVERIFIED
  PENDING
}

enum PermissionName {
  BUSINESS_CREATE
  BUSINESS_READ
  BUSINESS_UPDATE
  BUSINESS_DELETE
  MEMBERSHIP_ADD
  MEMBERSHIP_REMOVE
  ACCOUNT_CREATE
  ACCOUNT_READ
  ACCOUNT_UPDATE
  ACCOUNT_DELETE
  DEVICE_CREATE
  DEVICE_READ
  DEVICE_UPDATE
  DEVICE_DELETE
  REPORTS_VIEW
  REPORTS_EXPORT
  SETTINGS_MANAGE
}

model User {
  id                   String      @id @default(uuid()) @db.Uuid
  email                String      @unique
  firstName            String
  lastName             String
  dateOfBirth          DateTime
  sex                  Sex
  verificationStatus   VerificationStatus @default(UNVERIFIED)
  roleId               String
  role                 Role        @relation(fields: [roleId], references: [id])
  accounts             Account[]   @relation("UserAccounts")
  devices              UserDevice[] @relation("UserDevices")

  // For future many-to-many relationship with Business
  businesses           Business[]  @relation("UserBusinesses")
}

model Business {
  id                    String    @id @default(uuid()) @db.Uuid
  name                  String
  domain                String?   @unique
  logo                  String?
  industry              String?
  description           String?
  location              String?
  phoneNumber           String?
  email                 String?
  websiteUrl            String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  userId                String?   @unique
  user                  User?     @relation(fields: [userId], references: [id])
  taglineCategories     TaglineCategory[] @relation("BusinessTaglineCategories")

  // For future many-to-many relationship with users
  users                 User[]    @relation("UserBusinesses")
}

model TaglineCategory {
  id                    String   @id @default(uuid()) @db.Uuid
  name                  String   @unique                // e.g., "Eco-friendly", "Luxury", "Tech-savvy", etc.
  businesses            Business[] @relation("BusinessTaglineCategories")
}

model Account {
  id                    String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  accountId             String
  providerId            String
  userId                String?  @db.Uuid
  password              String?
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  status                Status   @default(ACTIVE)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  user                  User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
}

model UserDevice {
  id        String   @id @default(uuid()) @db.Uuid
  deviceIp  String
  browser   String
  visitorId String
  timestamp DateTime @default(now())
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id])
}

model Role {
  id          String         @id @default(uuid()) @db.Uuid
  name        String         @unique
  permissions Permission[]   @relation("RolePermissions")
  users       User[]         @relation("RoleUsers")
}

model Permission {
  id    String         @id @default(uuid()) @db.Uuid
  name  PermissionName @unique
  roles Role[]         @relation("RolePermissions")
}

// Uncomment and use this to enable the many-to-many relationship

// model UserBusiness {
//   userId      String  @db.Uuid
//   businessId  String  @db.Uuid
//   user        User    @relation(fields: [userId], references: [id])
//   business    Business @relation(fields: [businessId], references: [id])
//   @id([userId, businessId])
// }
